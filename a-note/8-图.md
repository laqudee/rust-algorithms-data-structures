# 图 graph

- 图的概念及其使用方法
- Rust实现图数据结构
- 用图来解决各类问题

## 啥是图

- 图的方向可有可无，树中无环，图可以有环
- 图涉及到点、边、点边关系

- 图定义：
  - 顶点，是图的元素，有一个名称：键，一个顶点也可能有额外的信息：有效载荷
  - 边，图的另一个元素，🔗两个顶点，表明关系，边可以是单向的或者双向的。图中的边都是单向的名称为有向图
  - 权重，边的度量，用一个数值来表示从一个顶点到另一个顶点的距离、成本、时间、亲密度

- G = (V, E)
  - V：点集合
  - E：边集合

- (v, w, q)

- V = (V0, V1, V2, V3, V4,V5)
- E = ((V0, V1, 5), (V1, V2, 5), (V2, V3, 5), (V3, V4, 5)...)

- 路径，用顶点序列来表示点连接的前后顺序，如(v, w, x, y, z)
  - V5 -> V2 -> V3 -> V5

- 无环图或DAG图

## 图的存储形式

- 计算机是线性的，图是非线性的

- 存储方案：
  - 邻接矩阵，采用二维矩阵存储图的节点和边及权重，对于N个点的图来说，需要N2个空间
  - 邻接表

- 邻接矩阵比较浪费内存

- 在邻接表中，使用数组来保存所有顶点的主列表，然后图中的每个主顶点维护一个连接到其他顶点的链表

## 图的抽象类型

- 抽象数据结构
  - new()，创建一个空图，返回空图
  - add_vertex(v)，添加一个顶点
  - add_edge(fv, tv, w)，添加带权重的有向边，需要起点fv和终点tv，及权重，无返回值
  - get_vertex(vk)，在图中找到键为vk的点
  - get_vertices()，返回图中所有顶点的列表
  - vert_nums()，返回途中顶点数
  - edge_nums()，返回图中边数
  - contains(vk)，判断点是否在图中，返回布尔值
  - is_empty()

## 图的实现

- 点Vertex
- 边Edge
- 用矩阵来存储边关系

- Rust实现图

- 用Rust的HashMap实现邻接表图
  - 点是核心元素
  - 边是点的关系
  - Vertex
  - connects用来保存所有邻接点

- 图解决字梯问题

## 广度优先搜索

- 搜索顶点时的四种情况
  1. 顶点是新的，未被搜索，则将其着色为灰色
  2. 顶点的前导被设置为当前节点
  3. 到顶点的距离设置为当前距离加1
  4. 顶点添加到队尾

- bfs对图中的每个顶点V最多执行一次while循环。性能O(v)
- 嵌套在while内部的for循环对图中的每个边执行最多一次，因为每个顶点最多被出队一次，性能O(E)

- 总的性能：O(V+E)

- 图搜索是最容易理解的解决方案
  1. 如何表示骑士在棋盘上的动作
  2. 查找长度为rows * columns - 1的路径
  - -1是因为自身所占格子不计入总数

## 深度优先遍历

- Rust 实现

- 深度优先搜索dfs中的循环都在O(V)中运行
- 循环对图中的每个边执行最多一次，其复杂度为O(E)

- 深度优先搜索的总时间性能为O(V+E)

- 拓扑排序，是深度优先搜索的一种改造，算法如下：
  1. 对图g调用dfs()，用深度优先搜索的来计算每个顶点的结束时间
  2. 以结束时间的递减顺序将顶点存储在列表中
  3. 返回有序列表作为拓扑排序的结果

- 深度优先森林

## 强连通分量

- 某些节点链接特别多

- 节点分区域聚集，高度互联

- 聚集的节点区域称为连通区域，节点是强连通的

- 强连通是指在某个区域内，从任意节点可在有限路径内到达另一个节点

- 强连通分量C属于图G，其中每个点v,w属于图G，且点v和w相互可达。

- 为了获取强连通分量，需要对图调用深度优先搜索。
  - 首先将图连接反转G^T，生成的图还是强连通的，且连通分量不变

- 计算强连通算法：
  1. 调用dfs为G计算每个点的结束时间
  2. 计算G^T，并为图G^T调用dfs，计算每个点结束时间
  3. 输出每个森林中每颗树顶点的标志组建

## 最短路径问题

- Dijkstra算法
  - 是一种贪心迭代算法，为我们提供了一个特定起始节点到图中所有其他节点的最短路径，类似于广度优先搜索

- Rust 实现Dijkstra算法

- 算法分析
  - 构建优先级队列需要O(V)，
  - 在循环中每次调用pop，需要O(logV)

- 总的时间复杂度：O((V+E)logV)
