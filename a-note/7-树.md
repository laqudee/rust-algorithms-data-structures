# 树

- 理解树极其使用方法
- 理解二叉树及平衡二叉树
- 用二叉堆实现优先级队列
- 实现二叉树及平衡树

## 啥是树

- 链表、栈、队列等数据结构都是线性的

- 如果对线性数据进行拓展，为数据节点连接多项，就是新的数据结构——树

- 包括操作系统、图形、数据库、计算机网络

- 树是分层的，具有良好的层次结构

- 一个节点的所有子节点独立于另一个节点的子节点

- 每个叶节点都是唯一的

- 定义树的各种属性：
  - 节点，是树的基本部分，或者叫键，还可以附加信息
  - 根，根是树中唯一没有传入边的节点，处于顶层
  - 边，边是树的另一个基本部分，又叫分支。边连接两个节点1⃣️保持之间存在的关系
  - 路径，路径是由边连接节点的有序序列，本身是不存在的，是由逻辑结构涌现出来的
  - 子节点
  - 父节点
  - 叶节点
  - 中间节点
  - 层数
  - 高度，树的高度等于树中任意节点的最大层数

- 树的定义：
  1. 树具有一个根节点
  2. 除根节点外，每个节点通过其他节点的边互相连接父和子节点（若有）
  3. 从根遍历到任何节点的路径全局唯一

- 左节点
- 右节点

- 用数组构建树

- 节点的方式保存树
  - 链表里面的链就是树里面的边

- 插入子节点，必须考虑两种情况
  1. 节点没有子节点，此时直接插入就行
  2. 节点具有子节点，则先将子节点接到新节点位置，然后再将新节点作为根的子节点

- 分析语法树

- 抽象语法树

- 树的遍历
  - 前序遍历
  - 中序遍历
  - 后序遍历

## 基于二叉堆的优先队列

- 优先级队列，队列的一个新变种，作用就像一个队列，可以通过从队首出队数据项。项的顺序不是按照加入的顺序，而是数据项本身的优先级确定

- 堆是一种完全二叉树，用来实现优先队列的堆又被称为二叉堆

- 二叉堆允许在O(logn)时间内排队和出队

- 小顶堆

- 大顶堆

- 基本操作：
  - new()
  - push(k)
  - pop()
  - min()
  - size()
  - is_empty()
  - build(arr)，从数组或vec构建新堆，需要保存数据的参数arr

- rust 实现二叉堆

- 平衡二叉堆在根的左右子树中具有大致相同数量的节点，尽量将每个节点填满，最多有一个节点的子节点不满

- 二叉堆虽然是放到Vec里面，线性放置，但其排序是按照树的方式操作的

- 排序时间复杂度： O(nlog2n)

- 构建需要处理所有n项数据，所以复杂度是O(n)

## 二叉查找树

- 类似于HashMap，也是用键来存储值

- 抽象数据类型：
  - new()
  - insert(k,v)
  - search(&k)，返回布尔值
  - get(&k)
  - max()
  - min()，返回树中最小键极其值v，不需要参数
  - len()，返回usize
  - is_empty()
  - iter()，返回树的迭代形式，不需要参数，不改变树
  - preorder()
  - inorder()
  - postorder()

- Rust实现二叉查找树
  - 二叉查找树左子节点键小于父节点的键
  - 右子节点的键要大于父节点的键
  - left < parent < right

- 删除节点
  - 删除一个键，首选找到它
  - 此时树可能存在三种情况：
    - 树没有节点
    - 树有一根节点
    - 树有若干节点

- 性能
  - O(log2(n))

## AVL平衡二叉树

- 要等到平衡的树，则需要满足平衡因子的要求

- 树的三种情况
  - 左重
  - 平衡
  - 右重

- 只要满足左重或右重的情况下依然满足平衡因子为-1，0，1的要求，则这样的左或右重树还是平衡的。

- 查找时的时间复杂度：O(logN)

- Rust实现平衡二叉树

- 两种情况不会更新平衡因子：
  - 递归调用已到达树根
  - 父节点的平衡因子已调整为零，其祖先节点的平衡因子不会改变

- 为AVL树添加插入节点的功能insert，然而插入节点后又需要处理平衡因子，所以还需要添加一个再平衡函数rebalance用于更新平衡因子

- Ord

- replace

- max

- AVL平衡二叉树相比二叉树添加了左旋和右旋操作，

-最差性能都是O(log2n)
