# 基本数据结构

1. 理解抽象数据结构：Vec、栈、队列、双端队列
2. 使用rust实现堆栈、队列、双端队列
3. 了解基本线性数据结构实现的性能
4. 了解前缀、中缀、后缀表达式格式
5. 使用栈实现后缀表达式并计算值
6. 使用栈将中缀表达式转换为后缀表达式
7. 什么问题使用栈、队列还是双端队列
8. 使用节点和引用将抽象数据类型实现为链表
9. 比较自己实现链表与Rust自带Vec的性能

## 线性数据结构

- 数组、栈、队列、双端队列

- 数据项之间的顺序由添加或删除的顺序决定，一旦数据项被添加，它相对于前后元素一直保持未知不变。

## 栈

- 可用于函数调用、网页数据记录。所有的操作都在顶端发生。先进后出

- 栈的抽象数据类型：
  - 项的有序集合
  - new()
  - push(item)
  - pop()
  - peek()，从栈返回顶部数据项，但不会删除它，不修改栈
  - is_empty()
  - size()

- Rust 实现栈
  - struct
  - Vec

- 括号匹配
  - 区分括号对计算机程序十分重要

- Rust实现括号匹配程序

- 处理`(a+b)(c*d)func()`

- Rust实现处理复杂字符串匹配

- 进制转换

- Rust实现二进制转换

- Rust实现将十进制转为二进制、八进制、十六进制

### 前中后缀表达式

- 中缀表达式：运算符处于两个操作数之间；A * B

- 前缀表达式：运算符在操作数之前；+ A B

- 后缀表达式：运算符在操作数之后； A B +

- 中缀转前后缀表达式
  - 中缀表达式需要转为前缀或后缀表达式后计算才高效
  - 方法一：采用完全括号表达式
    - 将运算符移到左括号位置，并删除该左括号与右括号，就转为了前缀表达式
    - 将运算符移到右括号位置，并删除对应的左右括号，就转为了后缀表达式
    - 困难点：将表达式转为完全括号表达式
    - 具体步骤：
      1. 创建一个名为op_stack的空栈以保存运算符。给输出创建一个空列表postfix
      2. 通过使用字符串方法拆分将输入的中缀字符串转换为标记列表 src_str
      3. 从左到右扫描标记列表
         1. 如果标记是操作数，将其附加到输出列表的末尾
         2. 如果标记是左括号，将其压到op_stack
         3. 如果标记是右括号，则弹出op_stack，直到删除相应左括号，将运算符加入postfix
         4. 如果标记是+ - * /，则压入op_stack。但先弹出op_stack中更高或相等优先级的运算符到postfix。
      4. 当输入处理完成，检查op_stack，仍在栈上的运算符都可弹出到postfix

- 要注意 `-` / 号，这个操作符不像 + 和 * 操作符。
  - `-` / 号需要注意操作数的顺序

## 队列

- 是项的有序集合，其中添加新项的一端称为队尾，移除项的一端称为队首

- 先进先出

- 有序集合，初始化给定容量，无法扩容
  - new()，创建一个新队列，返回一个空队列
  - enqueue(item)，将新项添加到队尾，不返回任何内容
  - dequeue()，从队首移除项，返回item，队列被修改
  - is_empty()，返回bool
  - size()，返回usize

- Rust实现队列

- 烫手山芋游戏

## 双端队列

- 与队列类似的项的有序集合
- 首端、尾端，都可以进行添加项和移除项的操作

- 抽象数据类型
  - new()
  - add_front(item)，添加到首端
  - add_rear(item)，添加到尾端
  - remove_front()，从首端移除
  - remove_rear()，从尾端移除
  - is_empty()
  - size()

- Rust实现双端队列

- 回文检测算法
  - 方法一：利用队列出栈入栈
  - 方法二：利用双端队列同时出栈

## 链表

- 有序的数据项集合能保证数据的相对位置，可以高效地索引

- 数组和链表都能做到将数据有序地收集并保存在相对的位置。

- Vec就是用的数组这种有序集合

- 数组是一片连续的内存，且增删元素涉及到内存复制和移动等操作，非常耗时。
- 链表不要求元素保存在连续的内存中

- 必须明确地指定链表的第一项位置，且每一项都保存下一项的索引

- 链头

- 抽象数据类型
  - new()，创建一个新的头节点用于指向Node，返回指针
  - push(item)，添加一个新的Node，需要item参数，返回Node
  - pop()，删除链表头节点，返回Node
  - peek()，返回链表头节点，返回对值的引用
  - peek_mut()，返回链表头节点，返回对值的引用
  - into_iter()，改变链表为可迭代形式
  - iter()，返回链表不可变迭代形式，链表不变
  - iter_mut()，返回链表可变迭代形式，链表不变
  - is_empty()
  - size()

- Rust实现链表
  - 每项都抽象成为一个节点，节点保存数据项和下一项索引
  - 节点还提供获取和修改数据项的方法

- 接地节点，将None显式的分配给next，为了避免C++等语言容易出现的悬荡指针

- IntoIter，将链表整个转换为可迭代类型
- Iter，只迭代，不修改链表
- IterMut，也迭代，但可以修改链表节点
- Drop类似析构函数

### 链表栈

- 使用链表实现栈，都是线性数据结构

- push和pop函数会改变链表的节点，所以使用了take函数来取出节点值

- Rust实现链表栈
